import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:coverage/coverage.dart' as coverage;

final _sep = path.separator;

List<File> findTestFiles(Directory packageRoot) {
  final testsPath = path.join(packageRoot.absolute.path, 'test');
  final testsRoot = new Directory(testsPath);
  final contents = testsRoot.listSync(recursive: true);
  final List<File> result = [];
  for (var item in contents) {
    if (item is! File) continue;
    if (!item.path.endsWith('_test.dart')) continue;
    result.add(item);
  }
  return result;
}

class TestFileInfo {
  final File testFile;
  final String alias;
  final String import;

  TestFileInfo._(this.testFile, this.alias, this.import);
  factory TestFileInfo.forFile(File testFile) {
    final parts = testFile.absolute.path.split(_sep).toList();
    List<String> relative = <String>[];
    while (parts.last != 'test') {
      relative.add(parts.last);
      parts.removeLast();
    }
    relative = relative.reversed.toList();
    final alias = relative.join('_').replaceFirst('.dart', '');
    final importPath = relative.join(_sep);
    final import = "import '$importPath' as $alias;";
    return new TestFileInfo._(testFile, alias, import);
  }
}

void generateMainScript(String packageRoot) {
  final testFiles = findTestFiles(new Directory(packageRoot));
  List<String> imports = [];
  List<String> mainBody = [];

  for (var test in testFiles) {
    final info = new TestFileInfo.forFile(test);
    imports.add(info.import);
    mainBody.add('  ${info.alias}.main();');
  }
  imports.sort();

  StringBuffer buffer = new StringBuffer();
  buffer.writeln('// Auto-generated by test_coverage. Do not edit by hand.');
  buffer.writeln('// Consider adding this file to your .gitignore.');
  buffer.writeln();
  imports.forEach(buffer.writeln);
  buffer.writeln();
  buffer.writeln('void main() {');
  mainBody.forEach(buffer.writeln);
  buffer.writeln('}');
  final file = new File(path.join(packageRoot, 'test', '.test_coverage.dart'));
  file.writeAsStringSync(buffer.toString());
}

Future<void> runTestsAndCollect(String packageRoot) async {
  final script = path.join(packageRoot, 'test', '.test_coverage.dart');
  var dartArgs = [
    '--pause-isolates-on-exit',
    '--enable_asserts',
    '--enable-vm-service',
    script
  ];

  var process = await Process.start('dart', dartArgs);
  var serviceUriCompleter = new Completer<Uri>();
  process.stdout
      .transform(utf8.decoder)
      .transform(const LineSplitter())
      .listen((line) {
    var uri = _extractObservatoryUri(line);
    if (uri != null) {
      serviceUriCompleter.complete(uri);
    }
  });

  var serviceUri = await serviceUriCompleter.future;
  Map<String, Map<int, int>> hitmap;
  try {
    final data = await coverage.collect(serviceUri, true, true);
    hitmap = coverage.createHitmap(data['coverage']);
  } finally {
    await process.stderr.drain<List<int>>();
  }
  int exitStatus = await process.exitCode;
  if (exitStatus != 0) {
    throw "Tests failed with exit code $exitStatus";
  }
  final resolver = new coverage.Resolver(
    packagesPath: path.join(packageRoot, '.packages'),
  );
  final lcov = new coverage.LcovFormatter(
    resolver,
    reportOn: ['lib${path.separator}'],
    basePath: packageRoot,
  );
  final coverageData = await lcov.format(hitmap);
  final coveragePath = path.join(packageRoot, 'coverage');
  final coverageDir = new Directory(coveragePath);
  if (!coverageDir.existsSync()) {
    coverageDir.createSync();
  }
  final coverageFile = new File(path.join(coveragePath, 'coverage.lcov'));
  coverageFile.writeAsStringSync(coverageData);
}

// copied from `coverage` package
Uri _extractObservatoryUri(String str) {
  const kObservatoryListening = 'Observatory listening on ';
  int msgPos = str.indexOf(kObservatoryListening);
  if (msgPos == -1) return null;
  int startPos = msgPos + kObservatoryListening.length;
  int endPos = str.indexOf(new RegExp(r'(\s|$)'), startPos);
  try {
    return Uri.parse(str.substring(startPos, endPos));
  } on FormatException {
    return null;
  }
}
