// Copyright (c) 2018, Anatoly Pulyaevskiy. All rights reserved. Use of this source code
// is governed by a BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:coverage/coverage.dart' as coverage;
import 'package:lcov/lcov.dart';
import 'package:path/path.dart' as path;

final _sep = path.separator;

List<File> findTestFiles(Directory packageRoot) {
  final testsPath = path.join(packageRoot.absolute.path, 'test');
  final testsRoot = new Directory(testsPath);
  final contents = testsRoot.listSync(recursive: true);
  final List<File> result = [];
  for (final item in contents) {
    if (item is! File) continue;
    if (!item.path.endsWith('_test.dart')) continue;
    result.add(item);
  }
  return result;
}

class TestFileInfo {
  final File testFile;
  final String alias;
  final String import;

  TestFileInfo._(this.testFile, this.alias, this.import);
  factory TestFileInfo.forFile(File testFile) {
    final parts = testFile.absolute.path.split(_sep).toList();
    List<String> relative = <String>[];
    while (parts.last != 'test') {
      relative.add(parts.last);
      parts.removeLast();
    }
    relative = relative.reversed.toList();
    final alias = relative.join('_').replaceFirst('.dart', '');
    final importPath = relative.join(_sep);
    final import = "import '$importPath' as $alias;";
    return new TestFileInfo._(testFile, alias, import);
  }
}

void generateMainScript(Directory packageRoot, List<File> testFiles) {
  final imports = <String>[];
  final mainBody = <String>[];

  for (final test in testFiles) {
    final info = new TestFileInfo.forFile(test);
    imports.add(info.import);
    mainBody.add('  ${info.alias}.main();');
  }
  imports.sort();

  final buffer = new StringBuffer();
  buffer.writeln('// Auto-generated by test_coverage. Do not edit by hand.');
  buffer.writeln('// Consider adding this file to your .gitignore.');
  buffer.writeln();
  imports.forEach(buffer.writeln);
  buffer.writeln();
  buffer.writeln('void main() {');
  mainBody.forEach(buffer.writeln);
  buffer.writeln('}');
  final file = new File(
    path.join(packageRoot.path, 'test', '.test_coverage.dart'),
  );
  file.writeAsStringSync(buffer.toString());
}

Future<void> runTestsAndCollect(String packageRoot) async {
  final script = path.join(packageRoot, 'test', '.test_coverage.dart');
  final dartArgs = [
    '--pause-isolates-on-exit',
    '--enable_asserts',
    '--enable-vm-service',
    script
  ];

  final process = await Process.start('dart', dartArgs);
  final serviceUriCompleter = new Completer<Uri>();
  process.stdout
      .transform(utf8.decoder)
      .transform(const LineSplitter())
      .listen((line) {
    final uri = _extractObservatoryUri(line);
    if (uri != null) {
      serviceUriCompleter.complete(uri);
    }
  });

  final serviceUri = await serviceUriCompleter.future;
  Map<String, Map<int, int>> hitmap;
  try {
    final data = await coverage.collect(serviceUri, true, true);
    hitmap = coverage.createHitmap(data['coverage']);
  } finally {
    await process.stderr.drain<List<int>>();
  }
  final exitStatus = await process.exitCode;
  if (exitStatus != 0) {
    throw "Tests failed with exit code $exitStatus";
  }
  final resolver = new coverage.Resolver(
    packagesPath: path.join(packageRoot, '.packages'),
  );
  final lcov = new coverage.LcovFormatter(
    resolver,
    reportOn: ['lib${path.separator}'],
    basePath: packageRoot,
  );
  final coverageData = await lcov.format(hitmap);
  final coveragePath = path.join(packageRoot, 'coverage');
  final coverageDir = new Directory(coveragePath);
  if (!coverageDir.existsSync()) {
    coverageDir.createSync();
  }
  final coverageFile = new File(path.join(coveragePath, 'lcov.info'));
  coverageFile.writeAsStringSync(coverageData);
}

// copied from `coverage` package
Uri _extractObservatoryUri(String str) {
  const kObservatoryListening = 'Observatory listening on ';
  final msgPos = str.indexOf(kObservatoryListening);
  if (msgPos == -1) return null;
  final startPos = msgPos + kObservatoryListening.length;
  final endPos = str.indexOf(new RegExp(r'(\s|$)'), startPos);
  try {
    return Uri.parse(str.substring(startPos, endPos));
  } on FormatException {
    return null;
  }
}

double calculateLineCoverage(File lcovReport) {
  final report = new Report.fromCoverage(lcovReport.readAsStringSync());
  int totalLines = 0;
  int hitLines = 0;
  for (final rec in report.records) {
    for (final line in rec.lines.data) {
      totalLines++;
      hitLines += (line.executionCount > 0) ? 1 : 0;
    }
  }
  return hitLines / totalLines;
}

void generateBadge(Directory packageRoot, double lineCoverage) {
  const leftWidth = 59;
  final value = (lineCoverage * 100).floor().toString() + '%';
  final color = _color(lineCoverage);
  final metrics = new _BadgeMetrics.forPercentage(lineCoverage);
  final rightWidth = metrics.width - leftWidth;
  final content = _kBadgeTemplate
      .replaceAll('{width}', metrics.width.toString())
      .replaceAll('{rightWidth}', rightWidth.toString())
      .replaceAll('{rightX}', metrics.rightX.toString())
      .replaceAll('{rightLength}', metrics.rightLength.toString())
      .replaceAll('{color}', color.toString())
      .replaceAll('{value}', value.toString());
  final file = new File(path.join(packageRoot.path, 'coverage', 'badge.svg'));
  file.writeAsStringSync(content);
}

class _BadgeMetrics {
  final int width;
  final int rightX;
  final int rightLength;

  _BadgeMetrics({this.width, this.rightX, this.rightLength});

  factory _BadgeMetrics.forPercentage(double value) {
    final pct = (value * 100).floor();
    if (pct.toString().length == 1) {
      return new _BadgeMetrics(
        width: 88,
        rightX: 725,
        rightLength: 190,
      );
    } else if (pct.toString().length == 2) {
      return new _BadgeMetrics(
        width: 94,
        rightX: 755,
        rightLength: 250,
      );
    } else {
      return new _BadgeMetrics(
        width: 102,
        rightX: 795,
        rightLength: 330,
      );
    }
  }
}

String _color(double percentage) {
  final map = {
    0.0: new _Color(0xE0, 0x5D, 0x44),
    0.5: new _Color(0xE0, 0x5D, 0x44),
    0.6: new _Color(0xDF, 0xB3, 0x17),
    0.9: new _Color(0x97, 0xCA, 0x00),
    1.0: new _Color(0x44, 0xCC, 0x11),
  };
  double lower;
  double upper;
  for (final key in map.keys) {
    if (percentage < key) {
      upper = key;
      break;
    }
    if (key < 1.0) lower = key;
  }
  upper ??= 1.0;
  final lowerColor = map[lower];
  final upperColor = map[upper];
  final range = upper - lower;
  final rangePct = (percentage - lower) / range;
  final pctLower = 1 - rangePct;
  final pctUpper = rangePct;
  final r = (lowerColor.r * pctLower + upperColor.r * pctUpper).floor();
  final g = (lowerColor.g * pctLower + upperColor.g * pctUpper).floor();
  final b = (lowerColor.b * pctLower + upperColor.b * pctUpper).floor();
  final color = new _Color(r, g, b);
  return color.toString();
}

class _Color {
  final int r, g, b;

  _Color(this.r, this.g, this.b);

  @override
  String toString() => "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toRadixString(16).substring(1);
}

const _kBadgeTemplate = '''
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="20">
  <linearGradient id="b" x2="0" y2="100%">
    <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
    <stop offset="1" stop-opacity=".1"/>
  </linearGradient>
  <clipPath id="a">
    <rect width="{width}" height="20" rx="3" fill="#fff"/>
  </clipPath>
  <g clip-path="url(#a)">
    <path fill="#555" d="M0 0h59v20H0z"/>
    <path fill="{color}" d="M59 0h{rightWidth}v20H59z"/>
    <path fill="url(#b)" d="M0 0h{width}v20H0z"/>
  </g>
  <g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="110">
    <text x="305" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="490">coverage</text>
    <text x="305" y="140" transform="scale(.1)" textLength="490">coverage</text>
    <text x="{rightX}" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="{rightLength}">{value}</text>
    <text x="{rightX}" y="140" transform="scale(.1)" textLength="{rightLength}">{value}</text>
  </g>
</svg>
''';
